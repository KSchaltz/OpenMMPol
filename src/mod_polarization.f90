module mod_polarization
    !! Module to handle the calculation of the induced dipoles; this means find
    !! the solution of the polarization problem. The polarization problem is 
    !! defined by the linear system 
    !! \begin{equation}
    !!    \mathbf{T}\mathbf{\mu} = \mathbf{E},
    !!    \label{eq:pol_ls}
    !! \end{equation}
    !! where \(\mathbf E\) is the 'external' (here external means the sum of the
    !! electric field generated by QM density and the one generated by the MM
    !! sites) electric field at induced dipole sites, \(\mathbf{\mu}\) are the 
    !! induced dipoles - the solution of the linear system -, and \(\mathbf{T}\)
    !! is the interaction tensor between the induced point dipoles.
    !!
    !! Linear system \eqref{eq:pol_ls} can be solved with different methods 
    !! (see [[mod_solvers]] for further details). Some of them requires to 
    !! explicitly build \(\mathbf{T}\) in memory (eg. 
    !! [[mod_solvers::inversion_solver]]), while other only requires to
    !! perform matrix-vector multiplication without building explicitly the
    !! interaction tensor.
    !! Interaction tensor is conveniently tought as a square matrix of dimension
    !! number of induced dipoles, of rank 3 tensors expressing the interaction
    !! between the two elements. We can distinguish the case of diagonal 
    !! elements:
    !! \begin{equation}
    !!    \mathbf T_{ii} = \frac{1}{\alpha_i} \mathbf I_3,
    !!    \label{eq:T_diag}
    !! \end{equation}
    !! and the off-diagonal elements:
    !! \begin{equation}
    !!    \mathbf T_{ij} = ...
    !!    \label{eq:T_offdiag}
    !! \end{equation}


    use mod_memory, only: ip, rp
    
    implicit none 
    private
    
    real(rp), allocatable :: TMat(:,:)
    !! Interaction tensor, only allocated for the methods that explicitly 
    !! requires it.

    public :: polarization
    
    contains
    
    subroutine polarization(e, ipds, arg_solver, arg_mvmethod)
        !! Main driver for the calculation of induced dipoles. 
        !! Takes electric field at induced dipole sites as input and -- if
        !! solver converges -- provides induced dipoles as output.
        !! Since AMOEBA requires the calculations of two sets of induced dipoles
        !! generated from two different electric fields (normally called direct (D) 
        !! and polarization (P)) both electric field and induced dipoles are shaped
        !! with an extra dimension and this routine calls the solver twice to 
        !! solve the two linear systems in the case of AMOEBA FF. Direct electric
        !! field and induced dipoles are stored in e(:,:,1)/ipds(:,:,1) while
        !! polarization field/dipole are stored in e(:,:,2)/ipds(:,:,2).

        use mod_mmpol, only: amoeba, pol_atoms, n_ipd, pol, fatal_error, verbose
        use mod_solvers, only: jacobi_diis_solver, conjugate_gradient_solver, &
                               inversion_solver
        use mod_memory, only: ip, rp, mallocate, mfree
        use mod_io, only: print_matrix
        use mod_constants, only: OMMP_MATV_DEFAULT, &
                                 OMMP_MATV_DIRECT, &
                                 OMMP_MATV_INCORE, &
                                 OMMP_SOLVER_DEFAULT, &
                                 OMMP_SOLVER_CG, &
                                 OMMP_SOLVER_DIIS, &
                                 OMMP_SOLVER_INVERSION, &
                                 OMMP_VERBOSE_DEBUG, &
                                 OMMP_AMOEBA_P, &
                                 OMMP_AMOEBA_D 
      
        implicit none

        real(rp), dimension(3, pol_atoms, n_ipd), intent(in) :: e
        !! Total electric field that induces the dipoles
        real(rp), dimension(3, pol_atoms, n_ipd), intent(out) :: ipds
        !! Induced dipoles

        integer(ip), intent(in), optional :: arg_solver
        !! Flag for the solver to be used; optional, should be one OMMP_SOLVER_
        !! if not provided [[mod_constants:OMMP_SOLVER_DEFAULT]] is used.
        integer(ip), intent(in), optional :: arg_mvmethod
        !! Flag for the matrix-vector method to be used; optional, should be one of
        !! OMMP_MATV_ if not provided [[mod_constants:OMMP_MATV_DEFAULT]] is used.
        
        real(rp), dimension(:, :), allocatable :: e_vec, ipd0
        real(rp), dimension(:), allocatable :: inv_diag
        integer(ip) :: i, n, solver, mvmethod

        abstract interface
        subroutine mv(x, y, dodiag)
                use mod_memory, only: rp, ip
                use mod_mmpol, only: pol_atoms
                real(rp), dimension(3*pol_atoms), intent(in) :: x
                real(rp), dimension(3*pol_atoms), intent(out) :: y
                logical, intent(in) :: dodiag
            end subroutine mv
        end interface
        procedure(mv), pointer :: matvec
        
        abstract interface
        subroutine pc(x, y)
                use mod_memory, only: rp, ip
                use mod_mmpol, only: pol_atoms
                real(rp), dimension(3*pol_atoms), intent(in) :: x
                real(rp), dimension(3*pol_atoms), intent(out) :: y
            end subroutine pc
        end interface
        procedure(pc), pointer :: precond
        
        ! Handling of optional arguments
        if(present(arg_solver)) then
            solver = arg_solver
        else
            solver = OMMP_SOLVER_DEFAULT
        end if

        if(present(arg_mvmethod)) then
            mvmethod = arg_mvmethod
        else
            mvmethod = OMMP_MATV_DEFAULT
        end if

        ! Dimension of the system
        n = 3*pol_atoms

        call mallocate('polarization [ipd0]', n, n_ipd, ipd0)
        call mallocate('polarization [e_vec]', n, n_ipd, e_vec)

        ! Allocate and compute dipole polarization tensor, if needed
        if(mvmethod == OMMP_MATV_INCORE .or. &
           solver == OMMP_SOLVER_INVERSION) then
            call mallocate('polarization [TMat]',n,n,TMat)
            call create_TMat(TMat)
        end if

        ! Reshape electric field matrix into a vector
        ! direct field for Wang and Amoeba
        ! polarization field just for Amoeba
        if(amoeba) then
            e_vec(:, OMMP_AMOEBA_D) = reshape(e(:,:,OMMP_AMOEBA_D), (/ n /))
            e_vec(:, OMMP_AMOEBA_P) = reshape(e(:,:,OMMP_AMOEBA_P), (/ n /))
        else
            e_vec(:, 1) = reshape(e(:,:, 1), (/ n /))
        end if
        
        ! Initialization of dipoles
        ipd0 = 0.0_rp
        
        if(solver /= OMMP_SOLVER_INVERSION) then
            ! Create a guess for dipoles
            if(amoeba) then
                call PolVec(e_vec(:, OMMP_AMOEBA_D), &
                            ipd0(:, OMMP_AMOEBA_D))
                call PolVec(e_vec(:, OMMP_AMOEBA_P), &
                            ipd0(:, OMMP_AMOEBA_P))
            else
                call PolVec(e_vec(:,1), ipd0(:,1))
            end if

            select case(mvmethod)
                case(OMMP_MATV_INCORE) 
                    matvec => TMatVec_incore

                case(OMMP_MATV_DIRECT)
                    matvec => TMatVec_otf

                case default
                    call fatal_error("Unknown matrix-vector method requested")
                
            end select
        end if
        
        if(verbose == OMMP_VERBOSE_DEBUG) then
            if(amoeba) then
                call print_matrix(.false., 'RHS (D)', n, 1, n, 1, &
                                  e_vec(:, OMMP_AMOEBA_D))
                call print_matrix(.false., 'RHS (P)', n, 1, n, 1, &
                                  e_vec(:, OMMP_AMOEBA_P))
            else
                call print_matrix(.false., 'RHS', n, 1, n, 1, e_vec)
            end if
            if(allocated(tmat)) &
                call print_matrix(.false., 'LHS', n, n, n, n, tmat)
        end if

        select case (solver)
            case(OMMP_SOLVER_CG)
                ! For now we do not have any other option.
                precond => PolVec

                if(amoeba) then
                    call conjugate_gradient_solver(n, &
                                                   e_vec(:,OMMP_AMOEBA_D), &
                                                   ipd0(:,OMMP_AMOEBA_D), &
                                                   matvec, precond)
                    call conjugate_gradient_solver(n, &
                                                   e_vec(:,OMMP_AMOEBA_P), &
                                                   ipd0(:,OMMP_AMOEBA_P), &
                                                   matvec, precond)
                else
                    call conjugate_gradient_solver(n, e_vec(:,1), ipd0(:,1), &
                                                   matvec, precond)
                end if

            case(OMMP_SOLVER_DIIS)
                ! Create a vector containing inverse of diagonal of T matrix
                call mallocate('polarization [inv_diag]', n, inv_diag)
                do i=1, pol_atoms
                    inv_diag(3*(i-1)+1:3*(i-1)+3) = pol(i) 
                end do

                if(amoeba) then
                    call jacobi_diis_solver(n, &
                                            e_vec(:,OMMP_AMOEBA_D), &
                                            ipd0(:,OMMP_AMOEBA_D), &
                                            matvec, inv_diag)
                    call jacobi_diis_solver(n, &
                                            e_vec(:,OMMP_AMOEBA_P), &
                                            ipd0(:,OMMP_AMOEBA_P), &
                                            matvec, inv_diag)
                else
                    call jacobi_diis_solver(n, e_vec(:,1), ipd0(:,1), &
                                            matvec, inv_diag)
                end if
                call mfree('polarization [inv_diag]', inv_diag)

            case(OMMP_SOLVER_INVERSION)
                if(amoeba) then
                    call inversion_solver(n, &
                                          e_vec(:,OMMP_AMOEBA_D), &
                                          ipd0(:,OMMP_AMOEBA_D), TMat)
                    call inversion_solver(n, &
                                          e_vec(:,OMMP_AMOEBA_P), &
                                          ipd0(:,OMMP_AMOEBA_P), TMat)
                else
                    call inversion_solver(n, e_vec(:,1), ipd0(:,1), TMat)
                end if
                
            case default
                call fatal_error("Unknown solver for calculation of the induced point dipoles") 
        end select
        
        ! Reshape dipole vector into the matrix 
        ipds = reshape(ipd0, (/3_ip, pol_atoms, n_ipd/)) 
        
        call mfree('polarization [ipd0]', ipd0)
        call mfree('polarization [e_vec]', e_vec)
        if(allocated(TMat)) call mfree('polarization [TMat]',TMat)

    end subroutine polarization
    
    subroutine dipole_T(i, j, tens)
        !! This subroutine compute the interaction tensor (rank 3) between
        !! two polarizable sites i and j.
        !! This tensor is built according to the following rules: ... TODO
        use mod_mmpol, only : thole, cpol, pol, polar_mm, conn, &
                              amoeba, uscale, fatal_error
        use mod_constants, only : eps_rp
        use mod_electrostatics, only: screening_rules

        implicit none
        !                      
        ! Compute element of the polarization tensor TTens between
        ! polarizable cpol atom I and polarizable cpol atom J. On the
        ! TTens diagonal (I=J) are inverse polarizabilities and on the 
        ! off-diagonal dipole field.
        !
        ! Polarizabilities pol are defined for polarizable atoms only while 
        ! Thole factors are defined for all of them
        !
        integer(ip), intent(in) :: i 
        !! Index (in the list of polarizable sites) of the source site
        integer(ip), intent(in) :: j
        !! Index (in the list of polarizable sites) of the target site
        real(rp), dimension(3, 3), intent(out) :: tens
        !! Interaction tensor between sites i and j
        
        real(rp) :: dr(3)
        real(rp) ::  kernel(3), scalf
        logical :: to_do, to_scale

        integer(ip) :: ii, jj
         
        tens = 0.0_rp
        
        if(i == j) then
            tens(1, 1) = 1.0_rp / pol(i)
            tens(2, 2) = 1.0_rp / pol(i)
            tens(3, 3) = 1.0_rp / pol(i)
        else
            call screening_rules(i, 'P', j, 'P', '-', to_do, to_scale, scalf)
            if(to_do) then
                call new_damped_coulomb_kernel(polar_mm(i), polar_mm(j), &
                                               2, kernel, dr)
                ! Fill the matrix elemets
                do ii=1, 3
                    do jj=1, 3
                        if(ii == jj) then
                            tens(ii, ii) = kernel(2) - 3.0_rp * kernel(3) * dr(ii) ** 2
                        else
                            tens(jj, ii) = -3.0_rp * kernel(3) * dr(ii) * dr(jj)
                        end if
                    end do
                end do
                ! Scale if needed
                if(to_scale) tens = tens * scalf
            
            end if
        end if
    end subroutine dipole_T
        
    subroutine create_tmat(tmat)
        !! Explicitly construct polarization tensor in memory. This routine
        !! is only used to accumulate results from [[dipole_T]] and shape it in
        !! the correct way.

        use mod_mmpol, only : pol_atoms, verbose
        use mod_io, only: print_matrix
        use mod_constants, only: OMMP_VERBOSE_DEBUG, OMMP_VERBOSE_HIGH

        implicit none
        
        real(rp), dimension(3*pol_atoms, 3*pol_atoms), intent(out) :: tmat
        !! The interaction tensor to be computed
        real(rp), dimension(3, 3) :: tensor
        !! Temporary interaction tensor between two sites

        integer(ip) :: i, j, ii, jj
        
        if(verbose >= OMMP_VERBOSE_HIGH) &
            write(6, *) "Explicitly computing interaction matrix to solve the polarization system"

        ! Initialize the tensor with zeros
        tmat = 0.0_rp
        
        do i = 1, pol_atoms
            do j = 1, i
                call dipole_T(i, j, tensor)
                
                do ii=1, 3
                    do jj=1, 3
                        tmat((j-1)*3+jj, (i-1)*3+ii) = tensor(jj, ii)
                        tmat((i-1)*3+ii, (j-1)*3+jj) = tensor(jj, ii)
                    end do
                end do
            enddo
        enddo
        
        ! Print the matrix if verbose output is requested
        if(verbose == OMMP_VERBOSE_DEBUG) then
            call print_matrix(.true., 'Polarization tensor:', &
                              3*pol_atoms, 3*pol_atoms, &
                              3*pol_atoms, 3*pol_atoms, TMat)
        end if
        
    end subroutine create_TMat

    subroutine TMatVec_incore(x, y, dodiag)
        !! Perform matrix vector multiplication y = TMat*x,
        !! where TMat is polarization matrix (precomputed and stored in memory)
        !! and x and y are column vectors
        use mod_mmpol, only: pol_atoms
        implicit none
        
        real(rp), dimension(3*pol_atoms), intent(in) :: x
        !! Input vector
        real(rp), dimension(3*pol_atoms), intent(out) :: y
        !! Output vector
        logical, intent(in) :: dodiag
        !! Logical flag (.true. = diagonal is computed, .false. = diagonal is
        !! skipped)
        
        call TMatVec_offdiag(x, y)
        if(dodiag) call TMatVec_diag(x, y)
    
    end subroutine TMatVec_incore
    
    subroutine TMatVec_otf(x, y, dodiag)
        !! Perform matrix vector multiplication y = TMat*x,
        !! where TMat is polarization matrix (precomputed and stored in memory)
        !! and x and y are column vectors
        use mod_electrostatics, only: new_field_extD2D
        use mod_mmpol, only: pol_atoms
        implicit none
        
        real(rp), dimension(3*pol_atoms), intent(in) :: x
        !! Input vector
        real(rp), dimension(3*pol_atoms), intent(out) :: y
        !! Output vector
        logical, intent(in) :: dodiag
        !! Logical flag (.true. = diagonal is computed, .false. = diagonal is
        !! skipped)
        
        y = 0.0_rp
        call new_field_extD2D(y, x)
        y = -1.0_rp * y ! Why? TODO
        if(dodiag) call TMatVec_diag(x, y)
    
    end subroutine TMatVec_otf
       
    subroutine TMatVec_diag(x, y)
        !! This routine compute the product between the diagonal of T matrix
        !! with x, and add it to y. The product is simply computed by 
        !! each element of x for its inverse polarizability.
        use mod_mmpol, only: pol, pol_atoms

        implicit none

        real(rp), dimension(3*pol_atoms), intent(in) :: x
        !! Input vector
        real(rp), dimension(3*pol_atoms), intent(out) :: y
        !! Output vector

        integer(ip) :: i, ii

        do i=1, 3*pol_atoms
            ii = (i+2)/3
            y(i) = y(i) + x(i) / pol(ii)
        end do
    end subroutine TMatVec_diag

    subroutine TMatVec_offdiag(x, y)
        !! Perform matrix vector multiplication y = [TMat-diag(TMat)]*x,
        !! where TMat is polarization matrix (precomputed and stored in memory)
        !! and x and y are column vectors
        use mod_mmpol, only: pol_atoms
        use mod_memory, only: mallocate, mfree
        
        implicit none
        
        real(rp), dimension(:), intent(in) :: x
        !! Input vector
        real(rp), dimension(:), intent(out) :: y
        !! Output vector
        
        real(rp), dimension(:), allocatable :: d
        integer(ip) :: i, n

        n = 3*pol_atoms
        call mallocate('TMatVec_offdiag [d]', n, d)
        
        ! Subtract the diagonal from the T matrix
        do i = 1, n
            d(i) = tmat(i,i)
            tmat(i,i) = 0
        end do
        ! Compute the matrix vector product
        call dgemm('N', 'N', n, 1, n, 1.0_rp, tmat, n, x, n, 0.0_rp, y, n)
        
        do i = 1, n
            tmat(i,i) = d(i)
        end do

        call mfree('TMatVec_offdiag [d]', d)
    end subroutine TMatVec_offdiag

    subroutine PolVec(x,y)
        !! Perform matrix vector multiplication y = pol*x,
        !! where pol is polarizability vector, x and y are 
        !! column vectors
        use mod_mmpol, only : pol, pol_atoms
        
        implicit none
        
        real(rp), dimension(3*pol_atoms), intent(in) :: x
        !! Input vector
        real(rp), dimension(3*pol_atoms), intent(out) :: y
        !! Output vector
        
        integer(ip) :: i, indx
        
        do i = 1, 3*pol_atoms
            indx = (i+2)/3
            y(i) = pol(indx)*x(i)   
        enddo
        
    end subroutine PolVec

end module mod_polarization
