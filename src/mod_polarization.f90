module mod_polarization
    !! Module to handle the calculation of the induced dipoles; this means find
    !! the solution of the polarization problem. The polarization problem is 
    !! defined by the linear system 
    !! \begin{equation}
    !!    \mathbf{T}\mathbf{\mu} = \mathbf{E},
    !!    \label{eq:pol_ls}
    !! \end{equation}
    !! where \(\mathbf E\) is the 'external' (here external means the sum of the
    !! electric field generated by QM density and the one generated by the MM
    !! sites) electric field at induced dipole sites, \(\mathbf{\mu}\) are the 
    !! induced dipoles - the solution of the linear system -, and \(\mathbf{T}\)
    !! is the interaction tensor between the induced point dipoles.
    !!
    !! Linear system \eqref{eq:pol_ls} can be solved with different methods 
    !! (see [[mod_solvers]] for further details). Some of them requires to 
    !! explicitly build \(\mathbf{T}\) in memory (eg. 
    !! [[mod_solvers::inversion_solver]]), while other only requires to
    !! perform matrix-vector multiplication without building explicitly the
    !! interaction tensor.
    !! Interaction tensor is conveniently tought as a square matrix of dimension
    !! number of induced dipoles, of rank 3 tensors expressing the interaction
    !! between the two elements. We can distinguish the case of diagonal 
    !! elements:
    !! \begin{equation}
    !!    \mathbf T_{ii} = \frac{1}{\alpha_i} \mathbf I_3,
    !!    \label{eq:T_diag}
    !! \end{equation}
    !! and the off-diagonal elements:
    !! \begin{equation}
    !!    \mathbf T_{ij} = ...
    !!    \label{eq:T_offdiag}
    !! \end{equation}


    use mod_memory, only: ip, rp
    
    implicit none 
    private
    
    real(rp), allocatable :: TMat(:,:)
    !! Interaction tensor, only allocated for the methods that explicitly 
    !! requires it.

    public :: polarization
    
    contains
    
    subroutine polarization(e, ipds, arg_solver, arg_mvmethod)
        !! Main driver for the calculation of induced dipoles. 
        !! Takes electric field at induced dipole sites as input and -- if
        !! solver converges -- provides induced dipoles as output.
        !! Since AMOEBA requires the calculations of two sets of induced dipoles
        !! generated from two different electric fields (normally called direct (D) 
        !! and polarization (P)) both electric field and induced dipoles are shaped
        !! with an extra dimension and this routine calls the solver twice to 
        !! solve the two linear systems in the case of AMOEBA FF. Direct electric
        !! field and induced dipoles are stored in e(:,:,1)/ipds(:,:,1) while
        !! polarization field/dipole are stored in e(:,:,2)/ipds(:,:,2).

        use mod_mmpol, only: amoeba, pol_atoms, n_ipd, fatal_error
        use mod_solvers, only: jacobi_diis_solver, conjugate_gradient_solver, &
                               inversion_solver
        use mod_memory, only: ip, rp, mallocate, mfree
        use mod_constants, only: OMMP_MATV_DEFAULT, &
                                 OMMP_MATV_DIRECT, &
                                 OMMP_MATV_INCORE, &
                                 OMMP_SOLVER_DEFAULT, &
                                 OMMP_SOLVER_CG, &
                                 OMMP_SOLVER_DIIS, &
                                 OMMP_SOLVER_INVERSION
      
        implicit none

        real(rp), dimension(3, pol_atoms, n_ipd), intent(in) :: e
        !! Total electric field that induces the dipoles
        real(rp), dimension(3, pol_atoms, n_ipd), intent(out) :: ipds
        !! Induced dipoles

        integer(ip), intent(in), optional :: arg_solver
        !! Flag for the solver to be used; optional, should be one OMMP_SOLVER_
        !! if not provided [[mod_constants:OMMP_SOLVER_DEFAULT]] is used.
        integer(ip), intent(in), optional :: arg_mvmethod
        !! Flag for the matrix-vector method to be used; optional, should be one of
        !! OMMP_MATV_ if not provided [[mod_constants:OMMP_MATV_DEFAULT]] is used.
        
        real(rp), dimension(3*pol_atoms) :: ep_vec, ed_vec, ipd0_p, ipd0_d
        integer(ip) :: n, solver, mvmethod

        abstract interface
            subroutine mv(n, x, y)
                use mod_memory, only: rp, ip
                integer(ip), intent(in) :: n
                real(rp), dimension(n), intent(in) :: x
                real(rp), dimension(n), intent(out) :: y
            end subroutine mv
        end interface
        procedure(mv), pointer :: precnd, matvec
        
        ! Handling of optional arguments
        if(present(arg_solver)) then
            solver = arg_solver
        else
            solver = OMMP_SOLVER_DEFAULT
        end if

        if(present(arg_mvmethod)) then
            mvmethod = arg_mvmethod
        else
            mvmethod = OMMP_MATV_DEFAULT
        end if

        ! Dimension of the system
        n = 3*pol_atoms

        ! Allocate and compute dipole polarization tensor
        if(mvmethod == OMMP_MATV_INCORE .or. solver == OMMP_SOLVER_INVERSION) then
            call mallocate('polarization [TMat]',n,n,TMat)
            call create_TMat(TMat)
        end if

        ! Reshape electric field matrix into a vector
        ! direct field for Wang and Amoeba
        ed_vec = reshape(e(:,:,1), (/ n /))
        ! polarization field just for Amoeba
        if(amoeba) ep_vec = reshape(e(:,:,2), (/ n /))
        
        ! Initial guess for iterative solvers (zero for matrix inversion)

        ipd0_p = 0.0_rp   ! Initial guess for amoeba p dipoles
        ipd0_d = 0.0_rp   ! Initial guess for wang or amoeba d dipoles
        
        if(solver /= OMMP_SOLVER_INVERSION) then
            call PolVec(3*pol_atoms, ed_vec, ipd0_d)
            if(amoeba) call PolVec(3*pol_atoms, ep_vec, ipd0_p)

            select case(mvmethod)
                case(OMMP_MATV_INCORE) 
                   matvec => TMatVec_incore

                case(OMMP_MATV_DIRECT)
                    ! TODO
                    call fatal_error("This method is still to be implemented") 

                case default
                    call fatal_error("Unknown matrix-vector method requested")
                
            end select
        end if

        select case (solver)
            case(OMMP_SOLVER_CG)
                call conjugate_gradient_solver(n, ed_vec, ipd0_d, matvec, PolVec)
                if(amoeba) call conjugate_gradient_solver(n, ep_vec, ipd0_p, matvec, PolVec)

            case(OMMP_SOLVER_DIIS)
                call jacobi_diis_solver(n, ed_vec, ipd0_d, TMatVec_offdiag, PolVec)
                if(amoeba) call jacobi_diis_solver(n, ep_vec, ipd0_p, TMatVec_offdiag, PolVec)

            case(OMMP_SOLVER_INVERSION)
                call inversion_solver(n, ed_vec, ipd0_d, TMat)  
                if(amoeba) call inversion_solver(n, ep_vec, ipd0_p, TMat)
                
            case default
                call fatal_error("Unknown solver for calculation of the induced point dipoles") 
        end select
        
        ! Reshape dipole vector into the matrix 
        ipds(:,:,1) = reshape(ipd0_d, (/3_ip, pol_atoms/)) 
        if(amoeba) ipds(:,:,2) = reshape(ipd0_p, (/3_ip, pol_atoms/)) 
        
        if(allocated(TMat)) call mfree('polarization [TMat]',TMat)

    end subroutine polarization
    
    subroutine dipole_T(i, j, tens)
        !! This subroutine compute the interaction tensor (rank 3) between
        !! two polarizable sites i and j.
        !! This tensor is built according to the following rules: ... TODO
        use mod_mmpol, only : thole, cpol, pol, polar_mm, conn, &
                              amoeba, uscale, fatal_error
        use mod_constants, only : eps_rp

        implicit none
        !                      
        ! Compute element of the polarization tensor TTens between
        ! polarizable cpol atom I and polarizable cpol atom J. On the
        ! TTens diagonal (I=J) are inverse polarizabilities and on the 
        ! off-diagonal dipole field.
        !
        ! Polarizabilities pol are defined for polarizable atoms only while 
        ! Thole factors are defined for all of them
        !
        integer(ip), intent(in) :: i 
        !! Index (in the list of polarizable sites) of the source site
        integer(ip), intent(in) :: j
        !! Index (in the list of polarizable sites) of the target site
        real(rp), dimension(3, 3), intent(out) :: tens
        !! Interaction tensor between sites i and j
        
        real(rp) :: dr(3)
        real(rp) ::  coul_k(3), s

        integer(ip) :: ii, jj, ineigh, i_mm, j_mm
         
        tens = 0.0_rp
        
        if(i == j) then
            tens(1, 1) = 1.0_rp / pol(i)
            tens(2, 2) = 1.0_rp / pol(i)
            tens(3, 3) = 1.0_rp / pol(i)
        else
            ! Check if the interaction should be screened for some reason
            ! connected to the connectivity
            if(.not. amoeba) then
                s = 1.0_rp
                
                ! Convert index of i and j from polarizable to MM
                j_mm = polar_mm(j)
                i_mm = polar_mm(i)
                    
                do ineigh=1, 4
                    ! Possibly interaction between polarizable sites separated
                    ! by 1, 2, 3 or 4 bonds are screened using uscale parameter
                    
                    ! Check if j_mm is in the connectivity list of i_mm at distance
                    ! ineigh
                    if(any(conn(ineigh)%ci(conn(ineigh)%ri(i_mm): &
                                           conn(ineigh)%ri(i_mm+1)-1) == j_mm)) &
                        s = uscale(ineigh)
                end do
            else
                ! Amoeba should have uscale = 1.0_rp, so the dipole-dipole
                ! interaction are not screened on connectivity base
                s = 1.0_rp
            end if

            if(abs(s) < eps_rp) then
                ! The scale factor is zero, and so is the interaction tensor
                ! nothing should be computed
                return
            end if
            
            ! If the scale factor is not zero, the interaction tensor should
            ! be computed
            dr = cpol(:,j) - cpol(:,i)

            call new_damped_coulomb_kernel(polar_mm(i), polar_mm(j), 2, coul_k)

            ! Fill the matrix elemets
            do ii=1, 3
                do jj=1, 3
                    if(ii == jj) then
                        tens(ii, ii) = coul_k(2) - 3.0_rp * coul_k(3) * dr(ii) ** 2
                    else
                        tens(jj, ii) = -3.0_rp * coul_k(3) * dr(ii) * dr(jj)
                    end if
                end do
            end do
            
            if(abs(s-1.0_rp) > eps_rp) then
                ! If the scale factor is not one, then apply it
                tens = tens * s
            end if
        end if
    end subroutine dipole_T
        
    subroutine create_tmat(tmat)
        !! Explicitly construct polarization tensor in memory. This routine
        !! is only used to accumulate results from [[dipole_T]] and shape it in
        !! the correct way.

        use mod_mmpol, only : pol_atoms, verbose
        use mod_io, only: print_matrix
        use mod_constants, only: OMMP_VERBOSE_DEBUG, OMMP_VERBOSE_HIGH

        implicit none
        
        real(rp), dimension(3*pol_atoms, 3*pol_atoms), intent(out) :: tmat
        !! The interaction tensor to be computed
        real(rp), dimension(3, 3) :: tensor
        !! Temporary interaction tensor between two sites

        integer(ip) :: i, j, ii, jj
        
        if(verbose >= OMMP_VERBOSE_HIGH) &
            write(6, *) "Explicitly computing interaction matrix to solve the polarization system"

        ! Initialize the tensor with zeros
        tmat = 0.0_rp
        
        do i = 1, pol_atoms
            do j = 1, i
                call dipole_T(i, j, tensor)
                
                do ii=1, 3
                    do jj=1, 3
                        tmat((j-1)*3+jj, (i-1)*3+ii) = tensor(jj, ii)
                        tmat((i-1)*3+ii, (j-1)*3+jj) = tensor(jj, ii)
                    end do
                end do
            enddo
        enddo
        
        ! Print the matrix if verbose output is requested
        if(verbose == OMMP_VERBOSE_DEBUG) then
            call print_matrix(.true., 'Polarization tensor:', &
                              3*pol_atoms, 3*pol_atoms, &
                              3*pol_atoms, 3*pol_atoms, TMat)
        end if
        
    end subroutine create_TMat

    subroutine TMatVec_incore(n, x, y)
        !! Perform matrix vector multiplication y = TMat*x,
        !! where TMat is polarization matrix (precomputed and stored in memory)
        !! and x and y are column vectors
        implicit none
        
        integer(ip), intent(in) :: n
        !! Size of TMat
        real(rp), dimension(n), intent(in) :: x
        !! Input vector
        real(rp), dimension(n), intent(out) :: y
        !! Output vector
        
        ! initialize solution vector TODO needed?
        y = 0.0_rp
        ! Compute the matrix vector product
        call dgemm('N', 'N', n, 1, n, 1.0_rp, TMat, n, x, n, 0.0_rp, y, n)
    end subroutine TMatVec_incore
        
    subroutine TMatVec_offdiag(n,x,y)
        !! Perform matrix vector multiplication y = [TMat-diag(TMat)]*x,
        !! where TMat is polarization matrix (precomputed and stored in memory)
        !! and x and y are column vectors
        implicit none
        
        integer(ip), intent(in) :: n
        !! Size of TMat
        real(rp), dimension(n), intent(in)   :: x
        !! Input vector
        real(rp), dimension(n), intent(out) :: y
        !! Output vector
        
        real(rp), dimension(n,n) :: O
        integer(ip) :: i
        
        ! initialize solution vector and matrix
        y = 0.0_rp
        O = TMat
        ! Subtract the diagonal from the O matrix
        do i = 1, n
            O(I,I) = 0.0_rp
        end do
        ! Compute the matrix vector product
        call dgemm('N', 'N', n, 1, n, 1.0_rp, O, n, x, n, 0.0_rp, y, n)
    end subroutine TMatVec_offdiag

    subroutine PolVec(n,x,y)
        !! Perform matrix vector multiplication y = pol*x,
        !! where pol polarizability vector (stored in memory) x and y are 
        !! column vectors
        use mod_mmpol, only : pol
        
        implicit none
        
        integer(ip), intent(in) :: n
        !! Size of input vector (number of polarizable sites)
        real(rp), dimension(n),intent(in)   :: x
        !! Input vector
        real(rp), dimension(n), intent(out) :: y
        !! Output vector
        
        integer(ip) :: i, indx
        
        do i = 1, n
            indx = (i+2)/3
            y(i) = pol(indx)*x(i)   
        enddo
        
    end subroutine PolVec

end module mod_polarization
